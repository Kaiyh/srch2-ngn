<div id="content" > <!-- Table of content, id=content-->

<table><tbody><tr><td>

<div><h3><a style="text-decoration: none;color:#ee2e24" href="#doc">Content</a></h3></div>

&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#overview">1. Overview</a><br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#formula">2. Ranking Formula</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#dynamicRanking">3. Dynamic Ranking</a></br><br>
<
</td></tr></tbody></table>


</div> <!-- Table of content, id=content-->


</div> <!-- Sidebar -->


</td>


<td id="docBody" style="width:70%">

</br>

<div><table><tbody><tr><td>

<div><h3><a style="text-decoration: none;color:#ee2e24" href="#doc"></a></h3></div>


</td></tr></tbody></table></div>
#<center>SRCH2 Manual: Ranking</center>#{id="doc" style="color:#ee2e24" }
######<center>Version: 4.2.0, Date: November 27, 2013</center>{id="versionInfo" style="font-size: 12px; margin-top: -20px;"}

##Overview##{id="overview"}

The SRCH2 engine allows a user to customize the ranking of records by providing a framework with various tunable parameters that can be specified in the configuration file. In addition to using classic features such as TF/IDF, field boosts, and record boosts, the framework also provides more control specifically needed in the context of instant search and fuzzy search. In particular, the engine allows the user to control the following:

- How much penalty we want give to partial matches (e.g., "candy" vs "can" ) compared to complete-keyword matches (e.g., "can" vs "can), using the parameter "PrefixMatchPenalty"; and
- How much penalty we want give to fuzzy matches (e.g., "schwazeneger" vs "schwarzenegger") compared to exact matches using the parameter "FuzzyMatchPenalty".

##Ranking Formula##{id="formula"}

Now we give the details of the ranking function. Intuitively, for a query and a candidate record (document), we compute the score of each term in the query for the record, and take the summation of these scores as the overall score. We order the records based on their overall score. The engine guarantees that exact results are always ranked higher than fuzzy results.

Formally, let <i>Q</i> be a query with terms (keywords) <i>t_1</i>, <i>t_2</i>, ..., <i>t_k</i>. Let <i>r</i> be a record. We compute the score of <i>r</i> for <i>Q</i> as follows:

<center> score(<i>r</i>, <i>Q</i>) = TermScore(<i>r</i>, <i>t_1</i>) + TermScore(<i>r</i>, <i>t_2</i>) + ... + TermScore(<i>r</i>, <i>t_k</i>).</center>

For each term <i>t_i</i>, let <i>w_i</i> be a keyword in <i>r</i> that matches <i>t_i</i> (exactly or fuzzily). The TermScore(<i>r</i>, <i>t_i</i>) is computed as follows:

<center> TermScore(<i>r</i>, <i>t_i</i>) = TermRecordStaticScore(<i>r</i>, <i>t_i</i>) * NormalizedEdSimilarity(<i>w_i</i>, <i>t_i</i>) * PrefixMatchPenalty.</center>

The formula uses the following parameters:

<b>1. NormalizedEdSimilarity(<i>w_i</i>, <i>t_i</i>)</b>: it is the similarity between the query term and the record term, based on their edit distance and normalized by the length of the record term. It is calculated as follows:

<center> NormalizedEdSimilarity(<i>w_i</i>, <i>t_i</i>) = (1 - ed(<i>w_i</i>, <i>t_i</i>)/length(<i>t_i</i>)) * FuzzyMatchPenalty^ed. </center>

In the formula, "ed(<i>w_i</i>, <i>t_i</i>)" is the edit distance between <i>w_i</i> and <i>t_i</i>, with length(<i>t_i</i>) as its upper bound. The value "FuzzyMatchPenalty" (between 0 and 1) is specified in the configuration file. Its default value is 1.0.

<b>2. PrefixMatchPenalty</b>: It is 1 if term <i>t_i</i> is a complete keyword. If term <i>t_i</i> is a prefix, then PrefixMatchPenalty takes the value of the parameter "prefixMatchPenalty" specified in the [configuration file](example-demo/srch2-config.xml).

<b>3. TermRecordStaticScore(r, t_i)</b>: It is the static score of this term for this record, which is computed and stored during index construction. It uses an expression customizable in the configuration file. The expression can use the following parameters:

- <b>idf_score</b>: internal IDF score;
- <b>doc_boost</b>: the boost value of the record as specified in an attribute;
- <b>doc_length</b>: number of unique keywords in the record.

The expression allows operators such as +, -, /, *, (, ), 0-9, etc.

The "idf_score" uses the following formula:

<center> idf_score(<i>r</i>, <i>t_i</i>) = (1.0 + sumOfFieldBoosts(r, <i>t_i</i>) / sumOfAllFieldBoosts ) * idf(<i>t_i</i>).</center>

The value "sumOfFieldBoosts(<i>r</i>, <i>t_i</i>)" is the summation of the boosts of the attributes in which this keyword <i>t_i</i> appears in <i>r</i>, and "sumOfAllFieldBoosts" is the summation of the boosts of all the searchable attributes. Therefore, we can assign higher boosts to attributes to increase their weights in the ranking.

The value "idf(<i>t_i</i>)" is the inverted document frequency, calculated as follows:

<center>idf(<i>t_i</i>) = 1 + <i>log_e</i> (total # of documents/ (# of documents having term <i>t_i</i> + 1)).</center>

In the case where the record <i>r</i> has multiple keywords <i>w_i</i>'s that match term <i>t_i</i>, TermScore(<i>r</i>, <i>t_i</i>) is the largest value among them.

##Dynamic Ranking##{id="dynamicRanking"}

The final score of results can also be modified on a per query basis by appending a "qf" parameter to the query string. The "qf" string allows boosting of results based on the number of keywords of the query which fall in a particular attribute.
<p>
For example: 
<t>q=terminator&qf=title^10 

<t>will boost the runtime TermScore of "terminator" by a factor of 10, for the movie Terminator 2, since the record occurs in the "title".
<p>
For a record where multiple query keywords fall into the required attribute. Each of those keyword's runtime TermScore will be boosted by a factor of the log of the total number of matching keywords in that attribute.
<p>
For example:
<t>q=Monty AND Grail&qf=title^10

<t>the TermScore of "Monty" and "Grail" independently will be boosted by 10*ln(e+2-1) for the movie "Monty Python and the Holy Grail", since both keywords: "Monty" and "Grail" fall in the "title".

<p>
Multiple attributes can also be boosted at once by concating them together with a plus in the qf string.
<p>
For example:
<t>q=Carter&qf=title^10+director^5

<p>
<t>the runtime TermScore of "Carter", will be translated to the dynamic TermScore: T(Carter)*10+T(Carter)*5, for the movie "Coach Carter", since "Carter" occurs in both the "title" and the "director" attribute.
