<div id="content" > <!-- Table of content, id=content-->
<table><tbody><tr><td>
<div><h3><a style="text-decoration: none;color:#ee2e24" href="#doc">Content</a></h3></div>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#overview">1. Overview</a><br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#sampleQueries">2. Sample Queries</a><br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#basicConcepts">3. Basic Concepts</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#fields">3.1. Fields</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#terms">3.2. Terms</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#termModifiers">3.3. Term Modifiers</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#prefixSearch">3.3.1 Prefix Search</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#fuzzySearch">3.3.2 Fuzzy Search</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#boostingTerm">3.3.3 Boosting A Term</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#proximitySearch">3.3.4 Proximity Search</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#queryComponents">4. Query Components</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#localParams"/>5. Local Parameters</a><br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#queryParams">6. Query Parameters</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#mainQuery">6.1. Main Query ("q")</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#filterQuery">6.2. Filter Query ("fq")</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#fieldList">6.3. Field List ("fl")</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#facetParams">7. Facet Query Parameters</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#facetEnabled">7.1. Enabling Facet</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#facetField">7.2. Categorical Facet</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#facetByRange">7.3. Range Facet</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#facetStart">7.3.1 Facet Range Start</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#facetEnd">7.3.2 Facet Range End</a></br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#facetGap">7.3.3 Facet Range Gap</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#searchType">8. Search Type</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#sort">9. Sort</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#orderby">10. Order by</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#start">11. Start</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#rows">12. Rows</a></br><br>
&nbsp;&nbsp;&nbsp;<a style="text-decoration: none;color:#3366FF" href="#fetchById">13. Fetch a Record by ID</a></br><br>

</td></tr></tbody></table>

</div> <!-- Table of content, id=content-->

</div> <!-- Sidebar -->

</td>

<td id="docBody" style="width:70%">
</br>
<div><table><tbody><tr><td>
<div><h3><a style="text-decoration: none;color:#ee2e24" href="#doc"></a></h3></div>

</td></tr></tbody></table></div>
#<center>SRCH2 Manual: RESTful API - Search</center>#{id="doc" style="color:#ee2e24" }
######<center>Version: 4.1.0, October 13, 2013</center>{id="versionInfo" style="font-size: 12px; margin-top: -20px;"}

##1. Overview##{id="overview"}

The SRCH2 engine provides a RESTful API that receives a request (query, insert/delete/update, or a control message) and gives a response in the JSON format.  This documentation describes the detail of the search API.  It begins with a set of sample queries to give an overview of the query language. It then dives into the language with an explanation of its basic concepts. Then it gives details of the structural components of a query with emphasis on their syntax specifications.  

Refer to [this page](restful-insert-update-delete.html) about the insert/dete/update API and [this page](restful-control.html) about the control API. 

Note that each RESTful request needs to use a proper [URL encoder](http://www.w3schools.com/tags/ref_urlencode.asp) to be converted to characters in a format that can be transmitted properly.

##2. Sample queries##{id="sampleQueries"}

Let us start with sample queries to give an idea of the query syntax.
```
f1) curl -i "http://localhost:8081/search?q=algorithm"
```
In this query, we are searching for all records containing the word "algorithm". The result set will contain all records with the word "algorithm" in a [searchable field](configuration.html#fields), as specified in the configuration file.
```
f2) curl -i "http://localhost:8081/search?q=title:algorithm AND author:gnuth"
```
This query will get records with the word "algorithm" in its <i>title</i> field and the word "gnuth" in its <i>author</i> field.
```
f3) curl -i "http://localhost:8081/search?q=title:algorithm AND author:gnuth&fq=price:[10 TO 100]"
```
This query is similar to the previous one. The only difference is that in <i>f3</i>, we filter the results based on the <i>price</i> field. So the result set contains records with the word "algorithm" in their <i>title</i> field, the word "gnuth" in their <i>author</i> field, and have a <i>price</i> between 10 and 100 (both inclusive).
```
f4) curl -i "http://localhost:8081/search?q=title:algorithms AND author:gnuth&fq=price:[10 TO 100] AND boolexp$ discount>10 $"
```

The query <i>f4</i> exhibits the engine's ability to filter records using boolean expressions, in addition to values and ranges. In <i>f4</i>, the engine further filters the results based on their field <i>discount</i> having a value greater than 10.

```
f5) curl -i "http://localhost:8081/search?q=title:algorithms AND author:gnuth&fq=price:[10 TO 100] AND boolexp$ discount>10 $ &sort=category&orderby=asc"
```
This query is similar to <i>f4</i>. In <i>f5</i> we sort the result set of <i>f4</i> in an ascending order based on the record's <i>category</i> field.
```
f6) curl -i "http://localhost:8081/search?q=title:algorithms AND author:gnuth&fq=price:[10 TO 100] AND boolexp$ discount>10 $&facet=true&facet.field=category"
```
This query, again, is similar to query <i>f4</i>, except that the new query requests the engine to return faceted information for the record's <i>category</i> field.

Note: The response of each RESTful request is in the [JSON](http://www.json.org/) format.  The engine also supports the [JSONP](http://en.wikipedia.org/wiki/JSONP) format. In order to get the response data in JSONP, append a parameter field "callback" to the query URL. For example:
```
curl -i "http://localhost:8081/search?q=algorithm&callback=myfunc
```

##3. Basic Concepts{id="basicConcepts"}

Before going into queries and their components, let us first understand the basic elements of a query: <i>fields</i> and <i>terms</i>.

### 3.1. Fields {id="fields"}

When performing a search, we can either specify a field or use a default value. A field that is labeled as "[searchable](configuration.html#fields)" or "[indexed](configuration.html#fields)" can be searched with the syntax field name followed by a colon ":" and the search term. For example, suppose that the data contains two fields, <i>title</i> and <i>text</i>. To find the records with "algo" and "structure" in "title" field, we can use the following query:
```
title:algo AND structure
```
### 3.2. Terms {id="terms"}

There are two types of terms: "single term" and "phrase." A single term is a single word such as <i>algorithm</i> or <i>gnuth</i>. A phrase is a group of words surrounded by double quotes such as <i>"new york city"</i>.

### 3.3. Term Modifiers {id="termModifiers"}

The engine supports modifying query terms to provide a wide range of search options.

### 3.3.1. Prefix Search{id="prefixSearch"}

The engine supports prefix searches. For instance, the following query searches for records with a keyword that has the prefix "schwar":
```
q=schwar*
```

### 3.3.2. Fuzzy Search{id="fuzzySearch"}

The engine supports fuzzy searches based on <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a>. The engine does a fuzzy search when the tilde symbol (<i>~</i>) is added to the end of a single term. The engine uses a customizable threshold (normalized based on the term length) to determine the edit distance used in finding the set of matching keywords. We can also specify the edit-distance threshold by explicitly giving a normalized similarity threshold (a float number between 0 and 1) for a term. Let "s" be the similarity threshold for a term given in the query. The engine will use the formula "floor((1-s) * length(keyword))" as the edit-distance threshold to do the search. If "s=1", we do an exact search. As example, consider the following query:
```
q=schwarazenneggar~0.8
```

The internal edit-distance threshold is floor((1-0.8) * length("schwarazenneggar")) = floor(0.2 * 16) = 3. So the engine will find records with a keyword whose edit distance to the term "schwarazenneggar" is at most three.

The engine allows each fuzzy search term to specify its own similarity value.

If a term does not have a similarity value, e.g.,

```
schwarazenneggar~
```
the engine will use the similarity threshold specified in the [configuration file](configuration.html##queryTermSimilarityThreshold)

### 3.3.3. Boosting a Term{id="boostingTerm"}

The engine provides the relevance level of matching records based on its matching terms. To boost the importance of a given term, we can use the caret symbol (<i>^</i>) with a boost number at the end of the given term. The higher the boost value, the more relevant the term will be.

Boosting allows control over the relevance of a record by boosting the significance of its terms. For example, if we are searching for two terms "algorithm" and "science", and we want the term "algorithm" to be more relevant, we can boost it using the <i>^</i> symbol along with the boost value next to the term. We would type:
```
algorithm^4 AND science
```

The boost value must be a positive integer, and its default value is 1.

*Note:* we can specify all three modifiers to a single term, but the order of modifiers must always be prefix, boost, and then fuzzy. The following are valid query examples:
```
1) q=algo*^4~.6 AND science^~.8
2) q=algo^4~.6 AND science^~ AND comp*
3) q=algorithm~.6 AND science^5~.8
```
The following are <b>invalid</b> query examples:
```
Invalid query 1) q=algorithm^4*
Invalid query 2) q=algorithm~.4^3*
Invalid query 3) q=algorithm~.6*
```
### 3.3.4. Proximity Search{id="proximitySearch"}

The engine supports finding words that are within a specified proximity. To use this feature, we need to set the [enablePositionIndex](configuration.html#enablePositionIndex) flag in the configuration file to true.

To do a proximity search, we use the tilde symbol ("~") at the end of a phrase. For example, the following query searches for records with the keywords "algorithm" and "data" within 10 words of each other in a document:
```
q="algorithm data"~10
```

Notice that a proximity search does not support edit-distance-based fuzzy match, i.e., we do not allow typos in the keywords in the quotes.

##4. Understanding different query components{id="queryComponents"}

The components and sub-components of a query are shown in Figure 1. The "Local Parameters" have query-related meta data specification, and the "Query Parameters" include specifications for the main query, postprocessing filters, sorting, and facets.
<br>
<span ><a href="http://www.srch2.com" target="_blankt"><img style="width:100%" src="images/Srch2-querysyntax.png" /></a></span>
<center>Figure 1: Query Components</center>

##5. Local Parameters (LocalParams) {id="localParams"}

<i>LocalParams</i> stands for "local parameters." It provides a way to "localize" query behavior by specifying modifiers for the engine. In other words, LocalParams provides a way to add meta-data to certain argument types such as query strings.

To indicate a LocalParam, we prefix the target argument with curly braces containing a series of <i>key=value</i> pairs separated by a white space. So if the original query keyword is "algorithm", applying LocalParams would look something like <i>{k1=v1 k2=v2 k3=v3}algorithm</i>. For example, we can specify a default field in local parameters as follows:
```
q={defaultSearchFields=title}algorithm
```
The above query searches for records with the word "algorithm" in the field <i>title</i>. We can specify more than one defaultSearch field. We can also specify what logical operator to use between these fields. For example:
```
q={defaultFieldOperator=AND defaultSearchFields=author,title}algorithm
```

The above query will return records with the word "algorithm" in both <i>author</i> and <i>title</i> fields. If "algorithm" is present only in one of the specified defaultSearchFields, the engine will not return the record. If we want the engine to return a record with the word "algorithm" present in any of the given defaultSearchFields, then we can set the value of defaultFieldOperator to "OR". The corresponding query is the following:
```
q={defaultFieldOperator=OR defaultSearchFields=author,title}algorithm
```

The following are valid localParams:

 - [defaultSimilarityThreshold](configuration.html#queryTermSimilarityThreshold): a number between 0 and 1. For example, "0.8" is a valid similarity threshold in fuzzy search.    

 - [defaultBoostLevel](configuration.html#fieldBoost): a non-negative integer, e.g., 2.

 - [defaultPrefixComplete](configuration.html#queryTermType): 'PREFIX' or 'COMPLETE' (without quotes, case sensitive), indicating whether the term is treated as a prefix or a complete term.

 - defaultSearchFields: default fields to search in, e.g., <i>title</i>. We can specify more than one field by using comma (',') to separate them, e.g., 'defaultSearchFields=title,author,price' (without quotes).

 - defaultFieldOperator : 'AND' or 'OR' (without quotes). It's a boolean operator to be applied between the default search fields specified by comma-separated fields.

##6. Query Parameters {id="queryParams"}

### 6.1. q: Main query parameter{id="mainQuery"}

A search over a searchable field is denoted by its name and the search term separated with a colon ":". For example, consider the query below:
```
q=title:algorithm
```
It searches for the keyword "algorithm" in the field <i>title</i> of a record. If no field is provided, the engine will search on the ['indexed' field(s)](configuration.html#fields) as specified in the [configuration file](example-demo/srch2-config.xml). For example,
```
q=algorithm
```
The above query searches for the keyword "algorithm" in all the searchable fields as specified in the configuration file.<br>

*Note:* all the field names used in "q" must have their "searchable" property or "indexed" property set to true in the configuration file.

### 6.2. fq: Filter-query parameter{id="filterQuery"}

This parameter is used to specify a filter restricting the set of records returned, without influencing their scores. In the example below, only records having year equal to 2012 will return.
```
fq=year:2012
```
A range query allows us to match records whose field value is between a specified lower bound and upper bound (both inclusive). For example:
```
price:[10 TO 100]
```

The above query finds records whose <i>price</i> field has a value between 10 and 100 (both inclusive). <br>

Please note: range queries are not just for numerical fields. We could also use range queries on non-numerical fields. Example:
```
fruit:[apple TO banana]
```
This will find all records whose <i>fruit</i> value is alphabetically between "apple" and "banana" (both inclusive).

*Note:* the engine supports only one kind of boolean operator (OR or AND) between all the filter terms. The following are examples of valid arguments:
```
1) fq=popularity:[10 TO *] AND section:0 AND price:[* TO 100]
2) fq=popularity:[10 TO *] OR section:0 OR price:[* TO 100]
```
The first query returns the records with a popularity greater than or equal to 10 and <i>price</i> less than or equal to 100.

The engine supports specifying boolean expressions only as filters. These expressions must be surrounded by "boolexp$" and "$".
```
fq=popularity:[10 TO *] AND section:0 AND boolexp$numOfReviews * 5 + numOfLikes * 2 > 940$
```
Please note: for the predicate "boolexp$ numOfReviews * 5 + numOfLikes * 2 > 940$", the engine will evaluate the boolean expression between the two '$' signs, which in this case is "numOfReviews * 5 + numOfLikes * 2 > 940". Here <i>numOfReviews</i> and <i>numOfLikes</i> are two fields defined in the schema.

In filter query terms, we can use the "-" operator before a field:term binding to tell the engine to exclude the records from the results that match the given binding criterion. For example:
```
fq=-popularity:[10 TO *]
```
The above filter query will find records whose popularity is <b>less than</b> 10.

Please note: the attributes used in "fq" must have the "refining" property set to true in the configuration file. Also, only the attributes of type INT and FLOAT can be used in the "boolexp$$" block.

## 7. Facet Query Params {id="facetParams"}

### 7.1. facet {id="facetEnabled"}

It is either "true" or "false", indicating whether we want to enable faceting. To turn faceting on, we need to include the following
```
facet=true
```

Please note: facet must also be enabled from the configuration file by setting the
 ["facetEnabled"](configuration.html##facetEnabled) tag to true.

### 7.2. facet.field {id="facetField"}

This parameter specifies a field to be treated as a categorical facet. It finds the number of distinct values in the specified field and returns the number of records that match each value.This parameter can be specified multiple times to indicate multiple facet fields.
```
facet=true&facet.field=category&facet.field=genre
```

The query above includes <i>"facet=true"</i> to turn on faceting. The parameter <i>facet.field</i> requests the engine to include the facet response for the field <i>genre</i> in the response.
  
### 7.3. Facet by Range {id="facetByRange"}

###7.3.1 facet.range {id="facetRange"}

This parameter can be used to specify a field that should be treated as a range facet. This parameter allows us to specify names of fields treated as range facets. Example:
```
facet.range=price&facet.range=age
```
The response of the above query includes facet information for the <i>price</i> and <i>age</i> fields. <br>

Please note: the [configuration file](configuration.html#facetFields) should define the default <i>facet.start</i>, <i>facet.end</i>, and <i>facet.gap</i> values.

###7.3.2. facet.range.start {id="facetStart"}

It is the mininum value (inclusive) of the range. Example:
```
f.price.facet.start=0.0&f.age.facet.start=10
```
The above query defines the lower bounds of the facet ranges for <i>price</i> and <i>age</i> fields.

###7.3.3. facet.range.end {id="facetEnd"}

It is the upper bound (exclusive) of the range. Example:
```
f.price.facet.end=1000.0&f.age.facet.end=99
```
The above query defines the upper bounds of the facet ranges for <i>price</i> and <i>age</i> fields.

###7.3.4. facet.range.gap {id="facetGap"}

It is the size of each range starting from the minimum value. Example:
```
f.price.facet.gap=100&f.age.facet.gap=10
```
The above query defines the gap between each consecutive faceted value of the facet ranges for the <i>price</i> and <i>age</i> fields.

Note that all start, end, and gap values, if given in the query, will override the corresponding values in the configuration file.

*Note:* if the expected number of results of a query is greater than 10K, facet results are made based on the best 2000 results.

## 8. searchType{id="searchType"}

The engine offers three different strategies for searching records:

 - topK: The results will be sorted descending by their score. This score is calculated for each record. Not that this approach has a high performance, but does not support facet and sort operations. <br>
 - getAll: Use this strategy if facets and sort query parameters are needed.
 - geo: Use of a location-based search. Sort and facets are supported. <br>

The following are examples of using searchType:
```
1) searchType=topK
2) searchType=getAll
3) searchType=geo
4) searchType=getAll&sort=author
```
*Note:* if searchType is not included in the query, it is set to topK by default. However, if any facet or sort parameter is included in the query, the search type will be getAll.
*Note:* If searchType is 'getAll' and the expected number of results of the query is greater than 10K, estimated number of results is returned instead of exact number of results.

## 9. sort{id="sort"}

The engine's default behavior is to sort the results using a descending order by the overall score of each record. The user can specify sorting by other fields. For example:
```
sort=author,price,title
```
*Note:* if a sort request is included in the query, the returned records' scores are still those calculated scores by the engine, but the order of the results corresponds to the user specification.
*Note:* if the expected number of results of a query is greater than 10K, the ranking function is used to find the best 2000 results, which are then sorted based on the sort parameter and returned.

## 10. orderby{id="orderby"}

It specifies the order in which the result set should be sorted. Its default value is "desc" (descending). This order is valid for all the fields specified in the sort parameter.
```
orderby=asc
```
*Note:* the order specified in the <i>orderby</i> parameter will be applied to all the fields mentioned in the sort parameter. Currently, specifying different <i>orderby</i> values for different fields is not supported.

## 11. start{id="start"}

It is the offset in the complete result set of the query, where the set of returned records should begin. The default value is 0.
```
start=10
```

## 12. rows{id="rows"}

It indicates the number of records to return from the complete result set. Its default value is 0.
```
rows=7
```
This parameter and <i>start</i> can be used to implement pagination.

## 13. Fetch a Record by ID{id="fetchById"}

The SRCH2 engine provides an API that allows the user to fetch a record by giving its primary key value.  An example of such a request is:

```
curl -i "http://localhost:8081/search?docid=123"
```

which returns the record with "123" (text) as its primary key value. Note that the primary key is defined by the tag "uniqueKey" under the "schema" tag.
