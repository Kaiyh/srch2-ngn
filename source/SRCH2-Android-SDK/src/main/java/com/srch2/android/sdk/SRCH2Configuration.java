package com.srch2.android.sdk;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.HashMap;

final class SRCH2Configuration {

    static final String tab = "    ";
    static final String tabtab = "        ";

    static final String SRCH2_HOME_FOLDER_DEFAULT_NAME = "srch2/";
    static final String HOSTNAME = "127.0.0.1";

    private String fullPathOfSRCH2home = "srch2";
    private int maxSearchThreads = 1;
    private int port = 8081;
    private String authorizationKey ;

    final HashMap<String, Indexable> indexableMap = new HashMap<String, Indexable>();

    /**
     * It returns the SRCH2Home, path where engine stores the serialized files.
     * @return the full path of SRCH2 home
     */
    String getSRCH2Home() {
        return fullPathOfSRCH2home;
    }

    /**
     * This value specifies the path of a folder where the engine stores.
     * serialized index files.
     */
    void setSRCH2Home(String fullPath) {
        fullPathOfSRCH2home = fullPath;
    }

    /**
     * It returns the port to which the engine is bound.
     * @return the port number of the server
     */
    int getPort() {
        return port;
    }

    /**
     * It sets the port of the local machine to which the engine is bound.
     * @param port the port number
     */
    void setPort(int port) {
        this.port = port;
    }

    String getAuthorizationKey() { return this.authorizationKey; }

    String getUrlString() {
        return "http://" + HOSTNAME + ":" + getPort() + "/";
    }

    /**
     * Specifies the authorization key that enables access to the SRCH2 search server. This way
     * the SRCH2 search server will only respond to valid clients. If this method is not called and
     * the authorication key is not explicitly set, one will be generated by the <code>SRCH2Engine</code>.
     * <br><br>
     * Once this method is called and the authorization key explicitly set, any RESTful request of the
     * SRCH2 search server must contain in the HTTP URL the following key-value pair of the form:
     * OAuth=foobar
     * to validate the RESTful request for the SRCH2 search server.
     * <br><br>
     * Example: curl -i "http://localhost:8081/search?q=terminator&OAuth=foobar"
     *
     * @param authorizationKey the auth key
     */
    void setAuthorizationKey(String authorizationKey) {
        if (authorizationKey == null) {
            throw new NullPointerException("Authorization key cannot be null");
        }
        this.authorizationKey = authorizationKey;
    }

    SRCH2Configuration(Indexable firstIndex, Indexable... additionalIndexes) {
        validateIndexable(firstIndex);
        firstIndex.indexInternal = createIndex(new IndexDescription(firstIndex));
        indexableMap.put(firstIndex.getIndexName(), firstIndex);
        if (additionalIndexes != null) {
            for (Indexable idx : additionalIndexes) {
                validateIndexable(idx);
                idx.indexInternal = createIndex(new IndexDescription(idx));
                indexableMap.put(idx.getIndexName(), idx);
            }
        }
    }

    /**
     * This function adds IndexStructure objects into Configuration Object.
     * @param indexDescription indexDescription
     */
    IndexInternal createIndex(IndexDescription indexDescription) {
        IndexInternal indexInternal = new IndexInternal(indexDescription);
        checkIfIndexNameValidAndAreadyExistedThrowIfNot(indexDescription.getIndexName());
        return indexInternal;
    }

    void validateIndexable(Indexable indexable) {
        if (indexable == null) {
            throw new NullPointerException("Cannot initialize the SRCH2Engine when a null Indexable is passed.");
        }
        IndexDescription.throwIfNonValidIndexName(indexable.getIndexName());
        if (indexable.getSchema() == null) {
            throw new NullPointerException("Indexable " + indexable.getIndexName() + " cannot be initialized with null schema: verify getSchema() is returning a valid schema object.");
        }
        if (indexable.getHighlighter() == null) {
            throw new NullPointerException("Indexable " + indexable.getIndexName() + " cannot be initialized with null highlighter: verify getHighlighter() is returning a valid highlighter object.");
        }
        IndexDescription.throwIfNonValidFuzzinessSimilarityThreshold(indexable.getFuzzinessSimilarityThreshold());
        IndexDescription.throwIfNonValidTopK(indexable.getTopK());
    }

    void checkIfIndexNameValidAndAreadyExistedThrowIfNot(String indexName) {
        if (indexName == null) {
            throw new NullPointerException("Cannot pass null indexName.");
        } else if (indexName.length() < 1) {
            throw new IllegalArgumentException("Cannot pass empty string as indexName.");
        } else if (indexableMap.containsKey(indexName)) {
            throw new IllegalArgumentException("The string indexName already existed.");
        }
    }

    void checkIfIndexNameValidAndThrowIfNot(String indexName) {
        if (indexName == null) {
            throw new NullPointerException("Cannot pass null indexName.");
        } else if (indexName.length() < 1) {
            throw new IllegalArgumentException("Cannot pass empty string as indexName.");
        } else if (!indexableMap.containsKey(indexName)) {
            throw new IllegalArgumentException("The string indexName must correspond to the name of Indexable passed into SRCH2Configuration upon SRCH2Engine.initialization(...).");
        }
    }

    Indexable getIndexableAndThrowIfNotThere(String name) {
        checkIfIndexNameValidAndThrowIfNot(name);
        return indexableMap.get(name);
    }

    /** generates the configuration file literal that will be passed to the SRCH2Service */
    static String generateConfigurationFileString(SRCH2Configuration conf) {
        if (conf.indexableMap.size() == 0) {
            throw new IllegalStateException("No index provided");
        }
        String defaultIndexName = conf.indexableMap.values().iterator().next().getIndexName();
        StringBuilder configurationXML = new StringBuilder()
            .append("<config>\n\n")
            .append(tab).append("<srch2Home>").append(conf.fullPathOfSRCH2home).append("</srch2Home>\n")
            .append(conf.getAuthorizationKeyConfigurationNode())
            .append(tab).append("<listeningHostname>").append(HOSTNAME).append("</listeningHostname>\n")
            .append(tab).append("<listeningPort>").append(conf.getPort()).append("</listeningPort>\n")
            .append(tab).append("<heartBeatTimer>")
                        .append(String.valueOf(IPCConstants.HEART_BEAT_SERVER_CORE_SHUTDOWN_DELAY_SECONDS))
            .append("</heartBeatTimer>\n")
            .append(tab).append("<maxSearchThreads>").append(conf.maxSearchThreads).append("</maxSearchThreads>\n")
            .append(tab).append("<cores defaultCoreName=\"").append(defaultIndexName).append("\">\n\n");

        for (Indexable idxable : conf.indexableMap.values()) {
            configurationXML.append(idxable.indexInternal.getConf().indexStructureToXML()).append("\n");

        }

        configurationXML
            .append(tab).append("</cores>\n")
            .append("</config>\n");
        return configurationXML.toString();
    }

    private String getAuthorizationKeyConfigurationNode() {
        StringBuilder auth = new StringBuilder();
        if (authorizationKey == null) {
            authorizationKey = generateAuthorizationKey();
        }
        auth.append(tab)
                .append("<authorization-key>").append(this.authorizationKey).append("</authorization-key>\n");
        return auth.toString();

    }

    private String generateAuthorizationKey() {
        SecureRandom random = new SecureRandom();
        return new BigInteger(130, random).toString(32);
    }

    /** dumps the configuration file to the specified destination */
    void writeConfigurationFileToDisk(String destinationDiskPath) throws FileNotFoundException,
            UnsupportedEncodingException {
        PrintWriter writer = new PrintWriter(destinationDiskPath, "UTF-8");
        writer.println(generateConfigurationFileString(this));
        writer.close();
    }
}