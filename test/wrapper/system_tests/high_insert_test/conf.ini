
# Srch2: configuration file for the search server
#
# Please contact support@srch2.com if you have questions.
#
# In this documment, "attribute" and "field" are used interchangeably.
#


####################### Parameters on local filesystem ###############

# License key file. Make sure to set the path to the srch2 license key
# file provided with the package.
# REQUIRED.
license-file=../conf/srch2_license_key.txt

# REQUIRED, when "index-load-or-create" is set to 0.
data-file-path=./high_insert_test/data-all/index-500.json

# The file path to the folder where we store serialized index files.
# REQUIRED, when "index-load-or-create" is set to 1.
index-dir-path=./high_insert_test/index

# Path to the log file.  Notice that the time in the log file is UTC time.
# REQUIRED.
access-log-file=./high_insert_test/log.txt

# Primary key attribute of the data
# REQUIRED
primary-key=index

# Flag to indicate whether the primary key is searchable.
# 0 - NO
# 1 - YES
# OPTIONAL. Default value is 0
is-primary-key-searchable=0

# Attributes we want to search on in addition to the primary key. Specify them
# as comma separated entries, e.g., title,name,address,affiliation.
# REQUIRED
attributes-search=attr

# Flag to indicate whether the attribute-based search is supported.
# 0 - NO
# 1 - YES
# Note that to support attribute-based search, the number of searchable attributes cannot be bigger than 31.
support-attribute-based-search=0

# Attribute used as the boost value of a record
attribute-record-boost=relevance

#
# The following comments and parameters are related to ranking.
#
# Intuitively, for a query and a candidate record (document), we compute the score of each query
# term in the record, and take the summation of these scores as the overall
# score.  We order the records based on their overall score. The engine guarantees
# that exact results are always ranked higher than fuzzy results.
#
# Formally, let Q be a query with terms (keywords) t_1, t_2, ..., t_k.  Let r be a record.
# We compute the score of r for Q as follows:
#
#    score(r, Q) = TermScore(r, t_1) + TermScore(r, t_k) + ... + TermScore(r, t_k).
#
# For each term t_i, let w_i be a keyword in r that matches t_i (exactly or fuzzily).
# The TermScore(r, t_i) is computed as follows:
#
#  TermScore(r, t_i) = RecordStaticScore(r, t_i)
#                    * NormalizedEdSimilarity(w_i, t_i)
#                    * PrefixMatchingNoramlizer
#
# where
#    NormalizedEdSimilarity(w_i, t_i) = 1 - EditDistance(w_i, t_i)/length(t_i).
#    The upper bound of EditDistance(w_i, t_i) is length(t_i).
#
#    PrefixMatchingNoramlizer:
#         It is always 1 if term t_i is a complete keyword condition.
#         If term t_i is a prefix keyword condition, then PrefixMatchingNoramlizer takes
#         the value of the parameter "prefix-match-penalty" specified in this configuration file.
#
#    RecordStaticScore(r, t_i):
#         It is the static score of this term for this record, which is
#         computed and stored during index construction.  It uses
#         an expression customizable in this configuration file.  The expression
#         can use the following parameters:
#            - idf_score: internal IDF score;
#            - doc_boost: the boost value of the record as specified in an attribute
#                         (default value is 1);
#            - doc_length: number of unique keywords in the record.
#
#         The expression allows operators such as +, -, /, *, (, ), 0-9, etc.
#
#         The "idf_score" uses the following formula:
#             idf_score(r, t_i) = sumOfFieldBoosts(r, t_i) * idf(t_i);
#
#          "sumOfFieldBoosts(r, t_i)" is the summation of the boosts of the
#           attributes in which this keyword t_i appears in r.
#
#         "idf(t_i)" is the inversed document frequency:
#             idf(t_i) = log (total # of documents/ # of documents having term t_i).
#
#    In the case where the record r has multiple keywords w_i's that match term t_i,
#    TermScore(r, t_i) is the largest value among them.
#

record-score-expression=doc_boost+(1/(doc_length+1))
#record-score-expression=idf_score*doc_boost - #srch2 had put this in, but previous strategy seems to work better

# penalty for a prefix match.  This value is used to multiply the score of record for a term.
# default value = 0.95
prefix-match-penalty=0.95

# Boost values for searchable attributes.  A boost value is in the
# range [1,100].  If the value is outside the range, it will be set to
# 100.  Specify the boost values as comma separated entries. For
# example, the boosts for four searchable attributes can be specified
# as 10,35,55,15.
#
# OPTIONAL.
attribute-boosts=1

# Default query term boost
# OPTIONAL. Defaults to 1
#default-query-term-boost=1

# Default query term similarity boost
# OPTIONAL. Defaults to 0.5
default-query-term-similarity-boost=0.9

# Default query term similarity boost
# OPTIONAL. Defaults to 0.5
#default-query-term-length-boost=0.5

# Format of each json search response.
#  0: format "rid,edit_dist,matching_prefix,in_memory_record";
#  1: format "rid,edit_dist,matching_prefix". In this case, the engine will not store records in memory.
#  2: format "rid,edit_dist,matching_prefix,attributes_to_return".
# OPTIONAL. Its default value is 0.
search-response-format=0

# Default type of matching query terms
#  0: exact match
#  1: fuzzy match
# OPTIONAL. Its default value is 0.
default-query-term-match-type=0

# Default type for query terms.
#  0: a term is treated as a prefix;
#  1: a term is treated as a complete term;
# OPTIONAL. Its default value is 0.
default-query-term-type=0

# Number of results to retrieve
# OPTIONAL. Its default value is 10.
default-results-to-retrieve=10

######################### For incremental updates ########################
# The number of records after which newly inserted and deleted records
# are "merged" into the indexes.  Its minimum value is 10.
merge-every-n-seconds=15

# The number of write operations after which newly inserted and deleted records
# are "merged" into the indexes.
merge-every-m-writes=10

########################## HTTP server options ################################
# Hostname and port number of the server. Make sure the port is open.
# REQUIRED
listening-hostname=0.0.0.0
listening-port=8082

# Number of bytes in the cache. It should be in the range [50MB, 500MB].
# OPTIONAL. Its default value is 50MB.
cache-size=104857600

# Number of threads that serve the requests.
# OPTIONAL. Its default value is 1.
number-of-threads=2

# Maximum number of records that can be inserted into the engine.
doc-limit=15000000

##################### Do NOT change the following parameters ###########################

# 1 - File BootStrap True - Import data from json file at file path "file-path".
# 0 - File bootstrap False
# OPTIONAL. Its default value is 1
data-source-type=1

# Index type.
#  - 0: Text Index
#  - 1: Spatial+Text Index
# REQUIRED
index-type=0

# Attributes that can be used to sort the results.
# OPTIONAL
attributes-sort=IGNORE

# Data type of attributes used to sort results:
#  0: if unsigned;
#  1: if float.
# OPTIONAL
attributes-sort-type=IGNORE
attributes-sort-default-value=IGNORE

# REQUIRED if index-type=1
attribute-latitude=IGNORE
attribute-longitude=IGNORE

# 0 - Insert using HTTP API
# 1 - Insert using KAFKA
# OPTIONAL. Defaults to 0
write-api-type=0
